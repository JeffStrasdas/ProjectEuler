-- Problem 1
problem_1 = sum (listofdiv 999)
	where		
		divisible n =
			if n `mod` 3 == 0 || n `mod` 5 == 0
				then n
				else 0
		listofdiv n = filter (>0) [divisible x | x <- [1..n]]

-- Problem 2
problem_2_old = sum (listRelFib 4000000)
	where
		isEven n = n `mod` 2 == 0

		fibonacci 0 = 1
		fibonacci 1 = 2
		fibonacci n = (fibonacci (n-1)) + (fibonacci (n-2))
		-- returns the highest index of the fibonacci sequence that is still below a given number
		highestNfibonacci n max = if (fibonacci (n+1)) < max
			then highestNfibonacci (n+1) max
			else n
		-- lists all even fibonacci numbers until a given index
		listRelFib n = filter isEven [fibonacci x | x <- [1..(highestNfibonacci 1 n)]]

problem_2 = sum (relFib 4000000)
	where
		isEven n = n `mod` 2 == 0
		-- infinite list of fibonacci numbers
		fib = 1 : 2 : [a+b | (a,b) <- zip fib (tail fib)]
		-- only take numbers until they reach the maximum
		relFib n = filter isEven (takeWhile (< n) fib)
		
-- Problem 3... too slow to be viable
problem_3 = last (primeFactors 600851475143)
	where
	numbers = 2 : map (+1) numbers
	--divisibleby :: (Integer,Integer) -> Bool
	divisibleby number divisor = number `mod` divisor == 0
	-- Returns True if number can be divided by _any_ of the divisors
	divisiblebyany number [] = False
	divisiblebyany number (divisor:divisors) = if (number > divisor)
		then (divisibleby number divisor) || (divisiblebyany number divisors)
		else False

	primes  = filter (>0) [if (divisiblebyany x numbers) then 0 else x | x <- numbers]
	--primes1 = 2 : [if (divisiblebyany x primes1) then 2 else x | x <- numbers]

	primeFactors n =  filter (>0) [if (divisibleby n p) then p else 0 | p <- takeWhile (< ((floor . sqrt . fromIntegral) n)) primes]

-- Problem 4
problem_4 = digit2number (last relevantPalindromes)
	where
	relevantNumbers = [x*y | x <- [100..999], y <- [100..999]]
	digits 0 = []
	digits n = n `mod` 10 : digits (n `div` 10)
	digit2number [] = 0
	digit2number (x:xs) = x + 10 * (digit2number xs)
	--isPalindrome :: [Integer] -> Bool
	isPalindrome [] = True
	isPalindrome (x:xs) = if xs == [] then True else x == last xs && isPalindrome (init xs)

	relevantPalindromes = filter isPalindrome [(digits x) | x <- relevantNumbers]

-- Problem 5
problem_5 = multiplyall usednumbers
	where
	isin number divisor = divisor `mod` number == 0
	-- Returns True if number can be generated by _any_ of the divisors
	isinany number [] = False
	isinany number (divisor:divisors) = (isin number divisor) || (isinany number divisors)

	multiplyall [] = 1
	multiplyall (x:xs) = x * multiplyall xs

	usednumbers = [if (isinany x [x+1..20]) then 1 else x | x<-[2..20]]

-- Problem 6
problem_6 = square_sum numbers - sum_square numbers
	where
	numbers = [1..100]
	sum_square [] = 0
	sum_square (x:xs) = x*x + sum_square xs
	square_sum xs = (sum xs)*(sum xs)

-- Problem 7... too slow to be viable
problem_7 = primes !! (10001 -1)
	where
	numbers = 2 : map (+1) numbers
	--divisibleby :: (Integer,Integer) -> Bool
	divisibleby number divisor = number `mod` divisor == 0
	-- Returns True if number can be divided by _any_ of the divisors
	divisiblebyany number [] = False
	divisiblebyany number (divisor:divisors) = if (number > divisor)
		then (divisibleby number divisor) || (divisiblebyany number divisors)
		else False

	primes  = filter (>0) [if (divisiblebyany x numbers) then 0 else x | x <- numbers]
		
	
	
	
	
	
	
	
	
	
	
	